using UnityEngine;

[RequireComponent(typeof(Light))]
public class CFGParticleShadow : MonoBehaviour
{
	public enum ParticleShadowResolution
	{
		x32 = 0x20,
		x64 = 0x40,
		x128 = 0x80,
		x256 = 0x100,
		x512 = 0x200,
		x1024 = 0x400,
		x2048 = 0x800
	}

	public ParticleShadowResolution m_ShadowMapResolution = ParticleShadowResolution.x256;

	[Range(0f, 5f)]
	public float m_ShadowStrength = 1f;

	public LayerMask m_ShadowCastingLayer;

	public bool m_UpdateShadowSettings;

	[Space(15f)]
	public float m_Bounds = 20f;

	private Light m_Light;

	private Camera m_Camera;

	private RenderTexture m_ShadowMap;

	private Shader m_ShadowShader;

	private float m_NearClip = -200f;

	private float m_FarClip = 300f;

	private float m_ZPos = -80f;

	private void Start()
	{
		if (!SystemInfo.supportsRenderTextures || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGB32))
		{
			base.enabled = false;
			Debug.LogWarning("This system does not support Render Textures or RenderTextureFormat.ARGB32. Disabling CFGParticleShadow.", base.gameObject);
			return;
		}
		m_ShadowShader = Shader.Find("CFG/Custom/Particle Shadow");
		m_Light = base.gameObject.GetComponent<Light>();
		if ((bool)m_Light && (bool)m_ShadowShader)
		{
			m_Camera = new GameObject("ShadowGenerator").AddComponent<Camera>();
			m_Camera.transform.SetParent(base.gameObject.transform);
			m_Camera.transform.localPosition = new Vector3(0f, 0f, m_ZPos);
			m_Camera.transform.localEulerAngles = Vector3.zero;
			m_Camera.hideFlags = HideFlags.HideInInspector;
			m_Camera.cullingMask = m_ShadowCastingLayer;
			m_Camera.renderingPath = RenderingPath.Forward;
			m_Camera.orthographic = true;
			m_Camera.clearFlags = CameraClearFlags.Color;
			m_Camera.backgroundColor = new Color(1f, 1f, 1f, 1f);
			m_Camera.farClipPlane = m_FarClip;
			m_Camera.nearClipPlane = m_NearClip;
			m_ShadowMap = new RenderTexture((int)m_ShadowMapResolution, (int)m_ShadowMapResolution, 0, RenderTextureFormat.ARGB32);
			m_ShadowMap.filterMode = FilterMode.Bilinear;
			m_Camera.SetReplacementShader(m_ShadowShader, null);
			m_Camera.targetTexture = m_ShadowMap;
			m_Light.cookie = m_ShadowMap;
			Shader.SetGlobalFloat("_ParticleShadowStrength", m_ShadowStrength);
		}
		else
		{
			base.enabled = false;
		}
		if (m_Light.type != LightType.Directional)
		{
			Debug.LogWarning("Particle Shadow can only be generated by Directional Light!", base.gameObject);
		}
	}

	private void Update()
	{
		if ((bool)m_Light && (bool)m_Camera)
		{
			SetShadowSettings();
			m_Camera.orthographicSize = m_Bounds;
			m_Light.cookieSize = m_Bounds * 2f;
		}
		else
		{
			base.enabled = false;
			Debug.LogWarning("Either Light or ShadowCaster Camera has been destroyed. Disabling CFGParticleShadow!", base.gameObject);
		}
	}

	private void SetShadowSettings()
	{
		if (m_UpdateShadowSettings)
		{
			m_UpdateShadowSettings = false;
			m_Camera.targetTexture = null;
			m_Camera.cullingMask = m_ShadowCastingLayer;
			Object.DestroyImmediate(m_ShadowMap);
			m_ShadowMap = new RenderTexture((int)m_ShadowMapResolution, (int)m_ShadowMapResolution, 0, RenderTextureFormat.ARGB32);
			m_ShadowMap.filterMode = FilterMode.Bilinear;
			m_Camera.targetTexture = m_ShadowMap;
			Shader.SetGlobalFloat("_ParticleShadowStrength", m_ShadowStrength);
			m_Camera.Render();
			m_Light.cookie = m_ShadowMap;
		}
	}

	private void OnDisable()
	{
		if ((bool)m_Light)
		{
			m_Light.cookie = null;
		}
		if ((bool)m_Camera)
		{
			Object.DestroyImmediate(m_Camera);
		}
		Object.DestroyImmediate(m_ShadowMap);
	}

	private void OnDrawGizmosSelected()
	{
		if ((bool)m_Camera && (bool)m_Light)
		{
			Vector3 vector = new Vector3(0f, 0f, m_Camera.transform.localPosition.z + m_Camera.nearClipPlane);
			Vector3 b = new Vector3(0f, 0f, m_Camera.transform.localPosition.z + m_Camera.farClipPlane);
			Vector3 center = vector + new Vector3(0f, 0f, Vector3.Distance(vector, b) * 0.5f);
			Gizmos.color = Color.red;
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.DrawWireCube(center, new Vector3(m_Bounds * 2f, m_Bounds * 2f, Vector3.Distance(vector, b)));
			Gizmos.color = Color.blue;
			Gizmos.DrawWireSphere(m_Camera.transform.localPosition, 2f);
		}
	}
}
